// NRPy+ basic definitions, automatically generated from outC_NRPy_basic_defines_h_dict within outputC,
//    and populated within NRPy+ modules. DO NOT EDIT THIS FILE BY HAND.

// construct_NRPy_basic_defines_h(...,enable_SIMD=True) was called so we #include SIMD intrinsics:
#include "SIMD/SIMD_intrinsics.h"


//********************************************
// Basic definitions for module outputC:

#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "string.h" // "string.h Needed for strncmp, etc.
#include "stdint.h" // "stdint.h" Needed for Windows GCC 6.x compatibility, and for int8_t

#ifndef M_PI
#define M_PI 3.141592653589793238462643383279502884L
#endif
#ifndef M_SQRT1_2
#define M_SQRT1_2 0.707106781186547524400844362104849039L
#endif

#ifndef MIN
#define MIN(A, B) ( ((A) < (B)) ? (A) : (B) )
#endif
#ifndef MAX
#define MAX(A, B) ( ((A) > (B)) ? (A) : (B) )
#endif

#ifdef __cplusplus
#define restrict __restrict__
#endif
#define REAL double
//********************************************


//********************************************
// Basic definitions for module NRPy_param_funcs:
typedef struct __paramstruct__ {
  REAL AMAX;  // reference_metric::AMAX
  REAL Cart_CoM_offsetx;  // grid::Cart_CoM_offsetx
  REAL Cart_CoM_offsety;  // grid::Cart_CoM_offsety
  REAL Cart_CoM_offsetz;  // grid::Cart_CoM_offsetz
  REAL Cart_originx;  // grid::Cart_originx
  REAL Cart_originy;  // grid::Cart_originy
  REAL Cart_originz;  // grid::Cart_originz
  REAL P0_x;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::P0_x
  REAL P0_y;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::P0_y
  REAL P0_z;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::P0_z
  REAL P1_x;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::P1_x
  REAL P1_y;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::P1_y
  REAL P1_z;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::P1_z
  REAL S0_x;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::S0_x
  REAL S0_y;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::S0_y
  REAL S0_z;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::S0_z
  REAL S1_x;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::S1_x
  REAL S1_y;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::S1_y
  REAL S1_z;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::S1_z
  REAL SINHWAA;  // reference_metric::SINHWAA
  REAL bScale;  // reference_metric::bScale
  REAL bare_mass_0;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::bare_mass_0
  REAL bare_mass_1;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::bare_mass_1
  REAL dxx0;  // grid::dxx0
  REAL dxx1;  // grid::dxx1
  REAL dxx2;  // grid::dxx2
  REAL eta_damping;  // NRPyElliptic_codegen.NRPyElliptic_RHSs::eta_damping
  REAL f0_of_xx0;  // reference_metric::f0_of_xx0
  REAL f0_of_xx0__D0;  // reference_metric::f0_of_xx0__D0
  REAL f0_of_xx0__DD00;  // reference_metric::f0_of_xx0__DD00
  REAL f0_of_xx0__DDD000;  // reference_metric::f0_of_xx0__DDD000
  REAL f1_of_xx1;  // reference_metric::f1_of_xx1
  REAL f1_of_xx1__D1;  // reference_metric::f1_of_xx1__D1
  REAL f1_of_xx1__DD11;  // reference_metric::f1_of_xx1__DD11
  REAL f1_of_xx1__DDD111;  // reference_metric::f1_of_xx1__DDD111
  REAL f2_of_xx0_xx1;  // reference_metric::f2_of_xx0_xx1
  REAL f2_of_xx0_xx1__D0;  // reference_metric::f2_of_xx0_xx1__D0
  REAL f2_of_xx0_xx1__D1;  // reference_metric::f2_of_xx0_xx1__D1
  REAL f2_of_xx0_xx1__DD00;  // reference_metric::f2_of_xx0_xx1__DD00
  REAL f2_of_xx0_xx1__DD11;  // reference_metric::f2_of_xx0_xx1__DD11
  REAL f2_of_xx1;  // reference_metric::f2_of_xx1
  REAL f2_of_xx1__D1;  // reference_metric::f2_of_xx1__D1
  REAL f2_of_xx1__DD11;  // reference_metric::f2_of_xx1__DD11
  REAL f2_of_xx1__DDD111;  // reference_metric::f2_of_xx1__DDD111
  REAL f3_of_xx0;  // reference_metric::f3_of_xx0
  REAL f3_of_xx0__D0;  // reference_metric::f3_of_xx0__D0
  REAL f3_of_xx0__DD00;  // reference_metric::f3_of_xx0__DD00
  REAL f4_of_xx2;  // reference_metric::f4_of_xx2
  REAL f4_of_xx2__D2;  // reference_metric::f4_of_xx2__D2
  REAL f4_of_xx2__DD22;  // reference_metric::f4_of_xx2__DD22
  REAL invdx0;  // grid::invdx0
  REAL invdx1;  // grid::invdx1
  REAL invdx2;  // grid::invdx2
  REAL puncture_0_x;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::puncture_0_x
  REAL puncture_0_y;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::puncture_0_y
  REAL puncture_0_z;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::puncture_0_z
  REAL puncture_1_x;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::puncture_1_x
  REAL puncture_1_y;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::puncture_1_y
  REAL puncture_1_z;  // NRPyElliptic_codegen.NRPyElliptic_SourceTerm::puncture_1_z
  REAL time;  // NRPyElliptic_codegen.NRPyElliptic_RHSs::time
  REAL uu_wavespeed_at_OB;  // NRPyElliptic_codegen.NRPyElliptic_RHSs::uu_wavespeed_at_OB
  REAL vv_wavespeed_at_OB;  // NRPyElliptic_codegen.NRPyElliptic_RHSs::vv_wavespeed_at_OB
  REAL xx0;  // grid::xx0
  REAL xx1;  // grid::xx1
  REAL xx2;  // grid::xx2
  REAL xxmax0;  // grid::xxmax0
  REAL xxmax1;  // grid::xxmax1
  REAL xxmax2;  // grid::xxmax2
  REAL xxmin0;  // grid::xxmin0
  REAL xxmin1;  // grid::xxmin1
  REAL xxmin2;  // grid::xxmin2
  int Nxx0;  // grid::Nxx0
  int Nxx1;  // grid::Nxx1
  int Nxx2;  // grid::Nxx2
  int Nxx_plus_2NGHOSTS0;  // grid::Nxx_plus_2NGHOSTS0
  int Nxx_plus_2NGHOSTS1;  // grid::Nxx_plus_2NGHOSTS1
  int Nxx_plus_2NGHOSTS2;  // grid::Nxx_plus_2NGHOSTS2
  int has_outer_boundary;  // CurviBoundaryConditions.CurviBoundaryConditions_new_way::has_outer_boundary
  int outer_bc_type;  // CurviBoundaryConditions.CurviBoundaryConditions_new_way::outer_bc_type
} paramstruct;
//********************************************


//********************************************
// Basic definitions for module finite_difference:

// Set the number of ghost zones
// Note that upwinding in e.g., BSSN requires that NGHOSTS = FD_CENTDERIVS_ORDER/2 + 1 <- Notice the +1.
#define NGHOSTS 5
//********************************************


//********************************************
// Basic definitions for module reference_metric:
typedef struct __rfmstruct__ {
	REAL *restrict f0_of_xx0;
	REAL *restrict f0_of_xx0__D0;
	REAL *restrict f0_of_xx0__DD00;
	REAL *restrict f0_of_xx0__DDD000;
	REAL *restrict f1_of_xx1;
	REAL *restrict f1_of_xx1__D1;
	REAL *restrict f1_of_xx1__DD11;
	REAL *restrict f2_of_xx0_xx1;
	REAL *restrict f2_of_xx0_xx1__D0;
	REAL *restrict f2_of_xx0_xx1__D1;
	REAL *restrict f2_of_xx0_xx1__DD00;
	REAL *restrict f2_of_xx0_xx1__DD11;
	REAL *restrict f3_of_xx0;
	REAL *restrict f3_of_xx0__D0;
	REAL *restrict f3_of_xx0__DD00;
} rfm_struct;
//********************************************


//********************************************
// Basic definitions for module CurviBoundaryConditions:

// NRPy+ Curvilinear Boundary Conditions: Core data structures
// Documented in: Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb

#define EXTRAPOLATION_OUTER_BCS 0  // used to identify/specify params.outer_bc_type
#define RADIATION_OUTER_BCS     1  // used to identify/specify params.outer_bc_type

typedef struct __innerpt_bc_struct__ {
  int dstpt;  // dstpt is the 3D grid index IDX3S(i0,i1,i2) of the inner boundary point (i0,i1,i2)
  int srcpt;  // srcpt is the 3D grid index (a la IDX3S) to which the inner boundary point maps
  int8_t parity[10];  // parity[10] is a calculation of dot products for the 10 independent parity types
} innerpt_bc_struct;

typedef struct __outerpt_bc_struct__ {
  short i0,i1,i2;  // the outer boundary point grid index (i0,i1,i2), on the 3D grid
  int8_t FACEX0,FACEX1,FACEX2;  // 1-byte integers that store
  //                               FACEX0,FACEX1,FACEX2 = +1, 0, 0 if on the i0=i0min face,
  //                               FACEX0,FACEX1,FACEX2 = -1, 0, 0 if on the i0=i0max face,
  //                               FACEX0,FACEX1,FACEX2 =  0,+1, 0 if on the i1=i2min face,
  //                               FACEX0,FACEX1,FACEX2 =  0,-1, 0 if on the i1=i1max face,
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,+1 if on the i2=i2min face, or
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,-1 if on the i2=i2max face,
} outerpt_bc_struct;

typedef struct __bc_info_struct__ {
  int num_inner_boundary_points;  // stores total number of inner boundary points
  int num_pure_outer_boundary_points[NGHOSTS][3];  // stores number of outer boundary points on each
  //                                                  ghostzone level and direction (update min and
  //                                                  max faces simultaneously on multiple cores)
  int bc_loop_bounds[NGHOSTS][6][6];  // stores outer boundary loop bounds. Unused after bcstruct_set_up()
} bc_info_struct;

typedef struct __bc_struct__ {
  innerpt_bc_struct *restrict inner_bc_array;  // information needed for updating each inner boundary point
  outerpt_bc_struct *restrict pure_outer_bc_array[NGHOSTS*3]; // information needed for updating each outer
  //                                                             boundary point
  bc_info_struct bc_info;  // stores number of inner and outer boundary points, needed for setting loop
  //                          bounds and parallelizing over as many boundary points as possible.
} bc_struct;

/* PARITY TYPES FOR ALL GRIDFUNCTIONS.
 * SEE "Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb" FOR DEFINITIONS. */
static const int8_t evol_gf_parity[2] = { 0, 0 };
static const int8_t auxevol_gf_parity[3] = { 0, 0, 0 };
//********************************************


//********************************************
// Basic definitions for module MoL:
typedef struct __MoL_gridfunctions_struct__ {
  REAL *restrict y_n_gfs;
  REAL *restrict y_nplus1_running_total_gfs;
  REAL *restrict k_odd_gfs;
  REAL *restrict k_even_gfs;
  REAL *restrict auxevol_gfs;
  REAL *restrict diagnostic_output_gfs;
} MoL_gridfunctions_struct;
#define LOOP_ALL_GFS_GPS(ii) _Pragma("omp parallel for") \
  for(int (ii)=0;(ii)<Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1*Nxx_plus_2NGHOSTS2*NUM_EVOL_GFS;(ii)++)
//********************************************


//********************************************
// Basic definitions for module grid:
// EVOLVED VARIABLES:
#define NUM_EVOL_GFS 2
#define UUGF	0
#define VVGF	1


// AUXILIARY VARIABLES:
#define NUM_AUX_GFS 0


// AUXEVOL VARIABLES:
#define NUM_AUXEVOL_GFS 3
#define ADD_TIMES_AUUGF	0
#define PSI_BACKGROUNDGF	1
#define WAVESPEEDGF	2


// SET gridfunctions_f_infinity[i] = value of gridfunction i in the limit r->infinity:
static const REAL gridfunctions_f_infinity[NUM_EVOL_GFS] = { 0.0, 0.0 };

// Declare the IDX4S(gf,i,j,k) macro, which enables us to store 4-dimensions of
//   data in a 1D array. In this case, consecutive values of "i"
//   (all other indices held to a fixed value) are consecutive in memory, where
//   consecutive values of "j" (fixing all other indices) are separated by
//   Nxx_plus_2NGHOSTS0 elements in memory. Similarly, consecutive values of
//   "k" are separated by Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1 in memory, etc.
#define IDX4S(g,i,j,k)                                                  \
  ( (i) + Nxx_plus_2NGHOSTS0 * ( (j) + Nxx_plus_2NGHOSTS1 * ( (k) + Nxx_plus_2NGHOSTS2 * (g) ) ) )
#define IDX4ptS(g,idx) ( (idx) + (Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1*Nxx_plus_2NGHOSTS2) * (g) )
#define IDX3S(i,j,k) ( (i) + Nxx_plus_2NGHOSTS0 * ( (j) + Nxx_plus_2NGHOSTS1 * ( (k) ) ) )
#define LOOP_REGION(i0min,i0max, i1min,i1max, i2min,i2max)              \
  for(int i2=i2min;i2<i2max;i2++) for(int i1=i1min;i1<i1max;i1++) for(int i0=i0min;i0<i0max;i0++)
#define LOOP_OMP(__OMP_PRAGMA__, i0,i0min,i0max, i1,i1min,i1max, i2,i2min,i2max) _Pragma(__OMP_PRAGMA__) \
    for(int (i2)=(i2min);(i2)<(i2max);(i2)++) for(int (i1)=(i1min);(i1)<(i1max);(i1)++) for(int (i0)=(i0min);(i0)<(i0max);(i0)++)
#define LOOP_NOOMP(i0,i0min,i0max, i1,i1min,i1max, i2,i2min,i2max)      \
  for(int (i2)=(i2min);(i2)<(i2max);(i2)++) for(int (i1)=(i1min);(i1)<(i1max);(i1)++) for(int (i0)=(i0min);(i0)<(i0max);(i0)++)
#define LOOP_BREAKOUT(i0,i1,i2, i0max,i1max,i2max) i0=(i0max); i1=(i1max); i2=(i2max); break;
#define IS_IN_GRID_INTERIOR(i0i1i2, Nxx_plus_2NGHOSTS0,Nxx_plus_2NGHOSTS1,Nxx_plus_2NGHOSTS2, NG) \
  ( i0i1i2[0] >= (NG) && i0i1i2[0] < (Nxx_plus_2NGHOSTS0)-(NG) &&       \
    i0i1i2[1] >= (NG) && i0i1i2[1] < (Nxx_plus_2NGHOSTS1)-(NG) &&       \
    i0i1i2[2] >= (NG) && i0i1i2[2] < (Nxx_plus_2NGHOSTS2)-(NG) )

typedef struct __griddata__ {
  paramstruct params;
  REAL *restrict xx[3];
  bc_struct bcstruct;
  rfm_struct rfmstruct;
  MoL_gridfunctions_struct gridfuncs;
} griddata_struct;
//********************************************
