// NRPy+ basic definitions, automatically generated from outC_NRPy_basic_defines_h_dict within outputC,
//    and populated within NRPy+ modules. DO NOT EDIT THIS FILE BY HAND.



//********************************************
// Basic definitions for module outputC:

#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "string.h" // "string.h Needed for strncmp, etc.
#include "stdint.h" // "stdint.h" Needed for Windows GCC 6.x compatibility, and for int8_t
#include "time.h"

// Einstein Toolkit Interface
#include "cctk.h"
#include "cctk_Arguments.h"
#include "cctk_Parameters.h"

#ifndef M_PI
#define M_PI 3.141592653589793238462643383279502884L
#endif
#ifndef M_SQRT1_2
#define M_SQRT1_2 0.707106781186547524400844362104849039L
#endif

#ifndef MIN
#define MIN(A, B) ( ((A) < (B)) ? (A) : (B) )
#endif
#ifndef MAX
#define MAX(A, B) ( ((A) > (B)) ? (A) : (B) )
#endif

#ifdef __cplusplus
#define restrict __restrict__
#endif
#define REAL double
//********************************************


//********************************************
// Basic definitions for module NRPy_param_funcs:
typedef struct __paramstruct__ {
  REAL AMAX;  // reference_metric::AMAX
  REAL Cart_CoM_offsetx;  // grid::Cart_CoM_offsetx
  REAL Cart_CoM_offsety;  // grid::Cart_CoM_offsety
  REAL Cart_CoM_offsetz;  // grid::Cart_CoM_offsetz
  REAL Cart_originx;  // grid::Cart_originx
  REAL Cart_originy;  // grid::Cart_originy
  REAL Cart_originz;  // grid::Cart_originz
  REAL puncture_0_bare_mass;
  REAL puncture_1_bare_mass;
  REAL puncture_0_x;
  REAL puncture_0_y;
  REAL puncture_0_z;
  REAL puncture_1_x;
  REAL puncture_1_y;
  REAL puncture_1_z;
  REAL puncture_0_P_x;
  REAL puncture_0_P_y;
  REAL puncture_0_P_z;
  REAL puncture_1_P_x;
  REAL puncture_1_P_y;
  REAL puncture_1_P_z;
  REAL puncture_0_S_x;
  REAL puncture_0_S_y;
  REAL puncture_0_S_z;
  REAL puncture_1_S_x;
  REAL puncture_1_S_y;
  REAL puncture_1_S_z;
  const char *initial_lapse;
  REAL lapse_exponent;
  REAL SINHWAA;  // reference_metric::SINHWAA
  REAL bScale;  // reference_metric::bScale
  REAL dxx0;  // grid::dxx0
  REAL dxx1;  // grid::dxx1
  REAL dxx2;  // grid::dxx2
  REAL eta_damping;  // NRPyElliptic.NRPyElliptic_RHSs::eta_damping
  REAL f0_of_xx0;  // reference_metric::f0_of_xx0
  REAL f0_of_xx0__D0;  // reference_metric::f0_of_xx0__D0
  REAL f0_of_xx0__DD00;  // reference_metric::f0_of_xx0__DD00
  REAL f0_of_xx0__DDD000;  // reference_metric::f0_of_xx0__DDD000
  REAL f1_of_xx1;  // reference_metric::f1_of_xx1
  REAL f1_of_xx1__D1;  // reference_metric::f1_of_xx1__D1
  REAL f1_of_xx1__DD11;  // reference_metric::f1_of_xx1__DD11
  REAL f1_of_xx1__DDD111;  // reference_metric::f1_of_xx1__DDD111
  REAL f2_of_xx0_xx1;  // reference_metric::f2_of_xx0_xx1
  REAL f2_of_xx0_xx1__D0;  // reference_metric::f2_of_xx0_xx1__D0
  REAL f2_of_xx0_xx1__D1;  // reference_metric::f2_of_xx0_xx1__D1
  REAL f2_of_xx0_xx1__DD00;  // reference_metric::f2_of_xx0_xx1__DD00
  REAL f2_of_xx0_xx1__DD11;  // reference_metric::f2_of_xx0_xx1__DD11
  REAL f2_of_xx1;  // reference_metric::f2_of_xx1
  REAL f2_of_xx1__D1;  // reference_metric::f2_of_xx1__D1
  REAL f2_of_xx1__DD11;  // reference_metric::f2_of_xx1__DD11
  REAL f2_of_xx1__DDD111;  // reference_metric::f2_of_xx1__DDD111
  REAL f3_of_xx0;  // reference_metric::f3_of_xx0
  REAL f3_of_xx0__D0;  // reference_metric::f3_of_xx0__D0
  REAL f3_of_xx0__DD00;  // reference_metric::f3_of_xx0__DD00
  REAL f4_of_xx2;  // reference_metric::f4_of_xx2
  REAL f4_of_xx2__D2;  // reference_metric::f4_of_xx2__D2
  REAL f4_of_xx2__DD22;  // reference_metric::f4_of_xx2__DD22
  REAL invdx0;  // grid::invdx0
  REAL invdx1;  // grid::invdx1
  REAL invdx2;  // grid::invdx2
  REAL time;  // NRPyElliptic.NRPyElliptic_RHSs::time
  REAL xx0;  // grid::xx0
  REAL xx1;  // grid::xx1
  REAL xx2;  // grid::xx2
  REAL xxmax0;  // grid::xxmax0
  REAL xxmax1;  // grid::xxmax1
  REAL xxmax2;  // grid::xxmax2
  REAL xxmin0;  // grid::xxmin0
  REAL xxmin1;  // grid::xxmin1
  REAL xxmin2;  // grid::xxmin2
  int Nxx0;  // grid::Nxx0
  int Nxx1;  // grid::Nxx1
  int Nxx2;  // grid::Nxx2
  int Nxx_plus_2NGHOSTS0;  // grid::Nxx_plus_2NGHOSTS0
  int Nxx_plus_2NGHOSTS1;  // grid::Nxx_plus_2NGHOSTS1
  int Nxx_plus_2NGHOSTS2;  // grid::Nxx_plus_2NGHOSTS2
  int has_outer_boundary;  // CurviBoundaryConditions.CurviBoundaryConditions_new_way::has_outer_boundary
} paramstruct;
//********************************************


//********************************************
// Basic definitions for module finite_difference:

// Set the number of ghost zones
// Note that upwinding in e.g., BSSN requires that NGHOSTS = FD_CENTDERIVS_ORDER/2 + 1 <- Notice the +1.
#define NGHOSTS 5
//********************************************


//********************************************
// Basic definitions for module reference_metric:
typedef struct __rfmstruct__ {
	REAL *restrict f0_of_xx0;
	REAL *restrict f0_of_xx0__D0;
	REAL *restrict f0_of_xx0__DD00;
	REAL *restrict f0_of_xx0__DDD000;
	REAL *restrict f1_of_xx1;
	REAL *restrict f1_of_xx1__D1;
	REAL *restrict f1_of_xx1__DD11;
	REAL *restrict f2_of_xx0_xx1;
	REAL *restrict f2_of_xx0_xx1__D0;
	REAL *restrict f2_of_xx0_xx1__D1;
	REAL *restrict f2_of_xx0_xx1__DD00;
	REAL *restrict f2_of_xx0_xx1__DD11;
	REAL *restrict f3_of_xx0;
	REAL *restrict f3_of_xx0__D0;
	REAL *restrict f3_of_xx0__DD00;
} rfm_struct;
//********************************************

//********************************************
// Basic definitions for module NRPyEllipticET:
typedef struct __ADM_quantities_curvilinear__ {
  CCTK_INT Nxx0,Nxx1,Nxx2;
  CCTK_INT Nxx_plus_2NGHOSTS0,Nxx_plus_2NGHOSTS1,Nxx_plus_2NGHOSTS2;
  CCTK_REAL *xx[3];
  CCTK_REAL *alpha;
  CCTK_REAL *betaU0,*betaU1,*betaU2;
  CCTK_REAL *gammaDD00,*gammaDD01,*gammaDD02,*gammaDD11,*gammaDD12,*gammaDD22;
  CCTK_REAL *KDD00,*KDD01,*KDD02,*KDD11,*KDD12,*KDD22;
} ADM_quantities_curvilinear;
//********************************************


//********************************************
// Basic definitions for module CurviBoundaryConditions:

// NRPy+ Curvilinear Boundary Conditions: Core data structures
// Documented in: Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb
typedef struct __ghostzone_map__ {
  short i0,i1,i2; // i0,i1,i2 stores values from -1 (used to indicate outer boundary)
                  // to Nxx_plus_2NGHOSTS*. We assume that grid extents beyond the
                  // limits of short (i.e., beyond about 32,000) are unlikely. This
                  // can be easily extended if needed, though.
} gz_map;

typedef struct __parity__ {
  int8_t parity[10]; // We store the 10 parity conditions in 10 int8_t integers,
                     // one for each condition. Note that these conditions can
                     // only take one of two values: +1 or -1, hence the use of
                     // int8_t, the smallest C data type.
} parity_condition;

typedef struct __inner_bc__ {
  gz_map inner_bc_dest_pt;
  gz_map inner_bc_src_pt;
  int8_t parity[10]; // We store the 10 parity conditions in 10 int8_t integers,
                     // one for each condition. Note that these conditions can
                     // only take one of two values: +1 or -1, hence the use of
                     // int8_t, the smallest C data type.
} inner_bc;

typedef struct __outer_bc__ {
  gz_map outer_bc_dest_pt;
  int8_t FACEi0,FACEi1,FACEi2; // FACEi* takes values of -1, 0, and +1 only,
                               // corresponding to MAXFACE, NUL, and MINFACE
                               // respectively.
                               // Thus int8_t (one byte each, the smallest C
                               // type) is sufficient.
} outer_bc;

typedef struct __bcstruct__ {
  outer_bc **outer; // Array of 1D arrays, of length
                    //   [NGHOSTS][num_ob_gz_pts[which_outer_ghostzone_point]]

  inner_bc **inner; // Array of 1D arrays, of length
                    //   [NGHOSTS][num_ib_gz_pts[which_inner_ghostzone_point]]

  // Arrays storing number of outer/inner boundary ghostzone points at each ghostzone,
  //   of length NGHOSTS:
  int     *num_ob_gz_pts;
  int     *num_ib_gz_pts;
} bc_struct;

/* PARITY TYPES FOR ALL GRIDFUNCTIONS.
 * SEE "Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb" FOR DEFINITIONS. */
static const int8_t evol_gf_parity[2] = { 0, 0 };
static const int8_t auxevol_gf_parity[3] = { 0, 0, 0 };
//********************************************


//********************************************
// Basic definitions for module MoL:
typedef struct __MoL_gridfunctions_struct__ {
  REAL *restrict y_n_gfs;
  REAL *restrict y_nplus1_running_total_gfs;
  REAL *restrict k_odd_gfs;
  REAL *restrict k_even_gfs;
  REAL *restrict auxevol_gfs;
  REAL *restrict diagnostic_output_gfs;
} MoL_gridfunctions_struct;
#define LOOP_ALL_GFS_GPS(ii) _Pragma("omp parallel for") \
  for(int (ii)=0;(ii)<Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1*Nxx_plus_2NGHOSTS2*NUM_EVOL_GFS;(ii)++)
//********************************************


//********************************************
// Basic definitions for module grid:
// EVOLVED VARIABLES:
#define NUM_EVOL_GFS 2
#define UUGF	0
#define VVGF	1


// AUXILIARY VARIABLES:
#define NUM_AUX_GFS 0


// AUXEVOL VARIABLES:
#define NUM_AUXEVOL_GFS 3
#define ADD_TIMES_AUUGF	0
#define PSI_BACKGROUNDGF	1
#define WAVESPEEDGF	2


// SET gridfunctions_f_infinity[i] = value of gridfunction i in the limit r->infinity:
__attribute__ ((unused)) static const REAL gridfunctions_f_infinity[NUM_EVOL_GFS] = { 0.0, 0.0 };


// SET gridfunctions_wavespeed[i] = gridfunction i's characteristic wave speed:
__attribute__ ((unused)) static REAL gridfunctions_wavespeed[NUM_EVOL_GFS] = { 4.4793122676309114e+06, 4.4793122676309114e+06 };

// Declare the IDX4S(gf,i,j,k) macro, which enables us to store 4-dimensions of
//   data in a 1D array. In this case, consecutive values of "i"
//   (all other indices held to a fixed value) are consecutive in memory, where
//   consecutive values of "j" (fixing all other indices) are separated by
//   Nxx_plus_2NGHOSTS0 elements in memory. Similarly, consecutive values of
//   "k" are separated by Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1 in memory, etc.
#define IDX4S(g,i,j,k) \
  ( (i) + Nxx_plus_2NGHOSTS0 * ( (j) + Nxx_plus_2NGHOSTS1 * ( (k) + Nxx_plus_2NGHOSTS2 * (g) ) ) )
#define IDX4ptS(g,idx) ( (idx) + (Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1*Nxx_plus_2NGHOSTS2) * (g) )
#define IDX3S(i,j,k) ( (i) + Nxx_plus_2NGHOSTS0 * ( (j) + Nxx_plus_2NGHOSTS1 * ( (k) ) ) )
#define LOOP_REGION(i0min,i0max, i1min,i1max, i2min,i2max) \
  for(int i2=i2min;i2<i2max;i2++) for(int i1=i1min;i1<i1max;i1++) for(int i0=i0min;i0<i0max;i0++)
#define LOOP_OMP(__OMP_PRAGMA__, i0,i0min,i0max, i1,i1min,i1max, i2,i2min,i2max) _Pragma(__OMP_PRAGMA__) \
    for(int (i2)=(i2min);(i2)<(i2max);(i2)++) for(int (i1)=(i1min);(i1)<(i1max);(i1)++) for(int (i0)=(i0min);(i0)<(i0max);(i0)++)
#define LOOP_NOOMP(i0,i0min,i0max, i1,i1min,i1max, i2,i2min,i2max)      \
  for(int (i2)=(i2min);(i2)<(i2max);(i2)++) for(int (i1)=(i1min);(i1)<(i1max);(i1)++) for(int (i0)=(i0min);(i0)<(i0max);(i0)++)
#define LOOP_BREAKOUT(i0,i1,i2, i0max,i1max,i2max) i0=(i0max); i1=(i1max); i2=(i2max); break;
#define IS_IN_GRID_INTERIOR(i0i1i2, Nxx_plus_2NGHOSTS0,Nxx_plus_2NGHOSTS1,Nxx_plus_2NGHOSTS2, NG) \
  ( i0i1i2[0] >= (NG) && i0i1i2[0] < (Nxx_plus_2NGHOSTS0)-(NG) &&       \
    i0i1i2[1] >= (NG) && i0i1i2[1] < (Nxx_plus_2NGHOSTS1)-(NG) &&       \
    i0i1i2[2] >= (NG) && i0i1i2[2] < (Nxx_plus_2NGHOSTS2)-(NG) )

typedef struct __griddata__ {
  paramstruct params;
  REAL *restrict xx[3];
  bc_struct bcstruct;
  rfm_struct rfmstruct;
  MoL_gridfunctions_struct gridfuncs;
} griddata_struct;
//********************************************
